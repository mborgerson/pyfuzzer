#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function
import subprocess
import threading
import argparse
import time
import struct
import sys
import ctypes
import os
import os.path
import shlex

VERBOSE = False
MAP_SIZE = 64*1024
FORKSRV_FD = 198
SHM_ENV_VAR = '__AFL_SHM_ID'


###
### Following code is borrowed from https://github.com/albertz/playground/blob/master/shared_mem.py
### It is used to call into libc to do shared memory mapping
###

libc_so = {"darwin": "libc.dylib", "linux2": ""}[sys.platform]
libc = ctypes.CDLL(libc_so, use_errno=True, use_last_error=True)
shm_key_t = ctypes.c_int
IPC_PRIVATE = 0 # MB: Replace with ftok for uniqueness?
IPC_RMID = 0

# int shmget(key_t key, size_t size, int shmflg);
shmget = libc.shmget
shmget.restype = ctypes.c_int
shmget.argtypes = (shm_key_t, ctypes.c_size_t, ctypes.c_int)

# void* shmat(int shmid, const void *shmaddr, int shmflg);
shmat = libc.shmat
shmat.restype = ctypes.c_void_p
shmat.argtypes = (ctypes.c_int, ctypes.c_void_p, ctypes.c_int)

# int shmdt(const void *shmaddr);
shmdt = libc.shmdt
shmdt.restype = ctypes.c_int
shmdt.argtypes = (ctypes.c_void_p,)

# int shmctl(int shmid, int cmd, struct shmid_ds *buf);
shmctl = libc.shmctl
shmctl.restype = ctypes.c_int
shmctl.argtypes = (ctypes.c_int, ctypes.c_int, ctypes.c_void_p)

# void* memcpy( void *dest, const void *src, size_t count );
memcpy = libc.memcpy
memcpy.restype = ctypes.c_void_p
memcpy.argtypes = (ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t)

# key_t ftok(const char *pathname, int proj_id);
ftok = libc.ftok
ftok.restype = shm_key_t
ftok.argtypes = (ctypes.c_char_p, ctypes.c_int)


class SharedMem:
    def __init__(self, size):
        self.size = size
        self.shmid = shmget(IPC_PRIVATE, self.size, 0o600)
        assert self.shmid >= 0
        self.ptr = shmat(self.shmid, 0, 0)
        assert self.ptr

    def remove(self):
        shmdt(self.ptr)
        self.ptr = None
        shmctl(self.shmid, IPC_RMID, 0)
        self.shmid = None

    def __del__(self):
        self.remove()

###
### End
###

class Program(threading.Thread):
    def __init__(self, prog, args=None):
        super(Program, self).__init__()
        self._prog = prog
        self._args = args or []
        self._stop_event = threading.Event()
        self._time_start = 0
        self._num_paths = 0
        self._last_path_time = 0.0
        self._num_crashes = 0
        self._last_crash_time = 0.0
        self._num_executions = 0

        self._stat_update_interval = 0.25
        self._stat_update_last = 0
        self._stat_display_wheel_iter = 0
    
    def time_elapsed_to_str(self, seconds):
        sec_per_min = 60
        sec_per_hour = sec_per_min * 60
        seconds = int(seconds)
        hours = int(seconds / sec_per_hour)
        seconds -= hours * sec_per_hour
        minutes = int(seconds / sec_per_min)
        seconds -= minutes * sec_per_min
        s = ''
        if hours > 0: s += '%dh' % hours
        if minutes > 0: s += '%dm' % minutes
        s += '%ds' % seconds
        return s

    def display_stats(self):
        wheel_icon = [
            '[.  ]',
            '[ . ]',
            '[  .]',
            '[ . ]',
        ]
        now = time.time()
        sys.stdout.write('\r' + ' ' * 80 + '\r') # Hacky terminal line blanker
        last_path_timestamp = 'N/A'
        if self._last_path_time > 0:
            last_path_timestamp = self.time_elapsed_to_str(now - self._last_path_time)
        last_crash_timestamp = 'N/A'
        if self._last_crash_time > 0:
            last_crash_timestamp = self.time_elapsed_to_str(now - self._last_crash_time)
        sys.stdout.write('%s %7s %6d exe, %4d paths (%s), %4d crashes (%s)' % (
            wheel_icon[self._stat_display_wheel_iter],
            self.time_elapsed_to_str(now - self._time_start),
            self._num_executions,
            self._num_paths, last_path_timestamp,
            self._num_crashes, last_crash_timestamp))
        self._stat_display_wheel_iter = (self._stat_display_wheel_iter + 1) % len(wheel_icon)
        sys.stdout.flush()

        #self._num_paths += 1
        #self._last_path_time = now
        #self._num_crashes += 1
        #self._last_crash_time = now

    def run(self):
        # Init shared memory region
        print('[ * ] Initializing shared memory')
        shm = SharedMem(MAP_SIZE)
        shm_buf = (ctypes.c_uint8 * MAP_SIZE).from_address(shm.ptr)
        for i in range(MAP_SIZE):
            shm_buf[i] = 0

        # Init fork server communication fifos
        print('[ * ] Creating fork server FIFOs')

        # FIFO1: fork server will read from this fifo before launching a new
        # fork. Stuff in 4 bytes to launch a fork.
        if os.path.exists('forksrv_in'):
            os.unlink('forksrv_in')
        os.mkfifo('forksrv_in')
        forksrv_in_fd = os.open('forksrv_in', os.O_RDWR)
        os.dup2(forksrv_in_fd, FORKSRV_FD) # QEMU expects this fd to be FORKSRV_FD

        # FIFO2: fork server will write to this fifo
        # -- Garbage at startup to see if it's alive
        # -- Child PID
        # -- Exit status of child
        if os.path.exists('forksrv_out'):
            os.unlink('forksrv_out')
        os.mkfifo('forksrv_out')
        forksrv_out_fd = os.open('forksrv_out', os.O_RDWR)
        os.dup2(forksrv_out_fd, FORKSRV_FD+1) # QEMU expects this fd to be FORKSRV_FD+1

        # Fire up the fork sesrver
        cmd = ['./qemu-x86_64', self._prog] + self._args
        print('[ * ] Launching fork server with command', ' '.join(cmd))
        os.environ[SHM_ENV_VAR] = str(shm.shmid)
        self._proc = subprocess.Popen(cmd,
            stdout=open('/dev/null'), # Sink program output to /dev/null
            stdin=open('/dev/null'),
            stderr=open('/dev/null'))
        if VERBOSE:
            print('    Shared Memory Segment Id: %d' % shm.shmid)
            print('    Fork server pid: %d' % self._proc.pid)
        sys.stdout.write('[ * ] Wating for fork server to become ready... ')
        os.read(FORKSRV_FD+1, 4)
        print('Ok')

        # Spawn some childen
        self._time_start = time.time()
        print('[ * ] Starting!')
        while True: #(time.time() - self._time_start) < 4.0:
            if self._stop_event.is_set():
                break

            # Spawn child
            if VERBOSE:
                sys.stdout.write('[ * ] Launching #%d ' % self._num_executions)
            start = time.time()
            os.write(FORKSRV_FD, '0000')
            inst_pid_enc = os.read(FORKSRV_FD+1, 4)
            if VERBOSE:
                print('(pid = %d)' % struct.unpack('<I', inst_pid_enc))

            # Wait for child to exit
            exit_enc = os.read(FORKSRV_FD+1, 4)
            stop = time.time()
            status = struct.unpack('<I', exit_enc)[0]
            if VERBOSE: sys.stdout.write('[ * ] Exit Status: %d ' % status)
            exit_signal = status & 0x7f
            if exit_signal == 0:
                if VERBOSE:
                    print('(Exit Normal, Code = %d)' % ((status & 0xff00) >> 8))
            else:
                # core_dump = status & 0x80
                if VERBOSE:
                    print('(Process Terminated, Signal = %d)' % exit_signal)

            if VERBOSE: print('[ * ] Process executed for %f seconds' % (stop-start))
            self._num_executions += 1

            if (time.time() - self._stat_update_last) > self._stat_update_interval:
                self._stat_update_last = time.time()
                self.display_stats()


        print('[ * ] Executed %d times' % self._num_executions)

        if VERBOSE:
            print('Shared Memory:')
            for i in range(MAP_SIZE/16):
                sys.stdout.write('%04x: ' % (i*16))
                for j in range(16):
                    sys.stdout.write('%02x ' % shm_buf[i*16+j])
                sys.stdout.write('\n')

        # Cleanup
        if self._proc.poll() is None:
            self._proc.kill()
        os.close(forksrv_in_fd)
        os.close(FORKSRV_FD)
        os.close(forksrv_out_fd)
        os.close(FORKSRV_FD+1)
        os.unlink('forksrv_in')
        os.unlink('forksrv_out')

    def stop(self):
        self._stop_event.set()
        # if self._proc.poll() is None:
        #     self._proc.kill()

def main():
    a = argparse.ArgumentParser()
    a.add_argument('target',            help='target executable')
    a.add_argument('args',              help='target arguments (@@ for input file)', nargs='?')
    a.add_argument('-i', '--inputdir',  help='seed input directory')
    a.add_argument('-o', '--outputdir', help='output data directory')
    a.add_argument('-v', '--verbose',   help='print debug output', action='store_true')
    a.set_defaults(target='a.out', inputdir='', outputdir='output', args='')
    args = a.parse_args()

    global VERBOSE
    VERBOSE = args.verbose
    p = Program(args.target, shlex.split(args.args))

    try:
        p.start()
        while p.isAlive():
            p.join(1)
    except KeyboardInterrupt as e:
        print('\nShutting Down!\n')
        p.stop()
    p.stop()

if __name__ == '__main__':
    main()